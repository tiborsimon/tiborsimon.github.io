<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Engineering with passion</title><link href="https://tiborsimon.io/" rel="alternate"></link><link href="https://tiborsimon.io/feeds/tools.atom.xml" rel="self"></link><id>https://tiborsimon.io/</id><updated>2016-04-01T00:00:00+02:00</updated><entry><title>My dotfile system</title><link href="https://tiborsimon.io/tools/my-dotfile-system/" rel="alternate"></link><updated>2016-04-01T00:00:00+02:00</updated><author><name>Tibor Simon</name></author><id>tag:tiborsimon.io,2016-04-01:tools/my-dotfile-system/</id><summary type="html">&lt;p&gt;Have you ever felt &lt;em&gt;crippled on a new machine&lt;/em&gt; you've just logged in for the first time? Tools missing, and if not, they have weird default configurations. Before you can start to work, you need to move in that machine: download all your needed tools, configure them one by one by hand. You quickly realize this is not the best way you can do..&lt;/p&gt;
&lt;div class="divider"&gt;Solution one&lt;/div&gt;

&lt;h1&gt;Externally saved configuration&lt;/h1&gt;
&lt;p&gt;You can speed up the initial configuration if you have a previously saved config file set in a machine independent storage, say Dropbox or a USB drive.&lt;/p&gt;
&lt;p&gt;These files are generally called &lt;strong&gt;dotfiles&lt;/strong&gt;, as command line tools often expect their configuration files to start with a dot indicating the file is hidden for normal use. Dotfiles are generally located in the current user's &lt;em&gt;home&lt;/em&gt; directory. When you start using a new machine, you simply  copy your saved config files to your home directory and you are home. &lt;/p&gt;
&lt;p&gt;Besides the custom configuration files, you can also save out a list of installable programs and tools that you want to have by default on a machine. Some package manager tools supports installing from files, but if not, you can write a small script that will install your tools one by one. You can create a &lt;code&gt;packages.txt&lt;/code&gt; file for this purpose:&lt;/p&gt;
&lt;div class="code-name"&gt;packages.txt&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;git
mc
vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;em&gt;one-by-one&lt;/em&gt; installer script could be something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;for app in &lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;path/to/your/packages.txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;; do &lt;/span&gt;
&lt;span class="x"&gt;  echo &amp;quot;Installing &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;app&lt;/span&gt;&lt;span class="x"&gt;..&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;  if &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;YOUR_PACKAGE_MANAGER&lt;/span&gt;&lt;span class="x"&gt; install -y &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;app&lt;/span&gt;&lt;span class="x"&gt;&amp;gt;temp_log_file 2&amp;gt;&amp;amp;1; then&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;app&lt;/span&gt;&lt;span class="x"&gt; installed.&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;  else&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;app&lt;/span&gt;&lt;span class="x"&gt; installation failed! Error: \n&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;temp_log_file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;  fi&lt;/span&gt;
&lt;span class="x"&gt;  rm -f temp_log_file&lt;/span&gt;
&lt;span class="x"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You might need to have administrator privileges to install packages on your machine. You have to replace the path to your &lt;em&gt;packages.txt&lt;/em&gt; file and your system's package manager.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;This method is semi-manual, as you have to copy the files, and run the commands yourself. It would be much more elegant if you would have a &lt;em&gt;one-command deployment&lt;/em&gt; solution. An another big drawback is the lack of version control (unless you have a local git repo on you USB drive). It is always a good idea to use versioning for &lt;strong&gt;anything&lt;/strong&gt; you do in you machine in case of an accident&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class="divider"&gt;Solution two&lt;/div&gt;

&lt;h1&gt;Hosted and versioned configuration&lt;/h1&gt;
&lt;p&gt;The next improvement step is to put your config files in a version control system, and host it on the internet. If you want a public configuration, you can't find better place than &lt;strong&gt;GitHub&lt;/strong&gt;. However, if you want your config to be in a private place, I can suggest using &lt;strong&gt;BitBucket&lt;/strong&gt;, as it offers free private repositories. Eihter versioning provider you choose, you will end up having an easy-to-deploy config system. You can clone your setup on a new machine, and you will have your setup ready to use.&lt;/p&gt;
&lt;p&gt;There is only one problem with this approach. If you clone your repository into your home directory, then your entire home directory will became a repository, but this is probably not what you want. You can solve this issue by cloning your repo into a separate directory, and then symlink your dotfiles into the expected place.&lt;/p&gt;
&lt;p&gt;This is the exact method I use for my dotfile system. I clone my dotfiles repository into the &lt;code&gt;~/.dotfiles&lt;/code&gt; directory, and then I run my deploy script, that will symlink the dotfiles one-by-one into their dedicated place. Then I only have to modify the dotfiles located in the &lt;code&gt;~/dotfiles&lt;/code&gt; directory, and my changes automatically appear in place.&lt;/p&gt;
&lt;p&gt;For deployment script, I use &lt;a href="https://github.com/holman/dotfiles"&gt;Zach Holman's dotfiles&lt;/a&gt; project that has a separated structure that I further customized to meet my needs.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Putting your dotfiles into a versioned repository and hosting it online gives you amazing flexibility. You can have your own configuration in any machine in minutes while keeping it on a dedicated place. You only need to clone your repository into a dedicated directory, and run your deployment script.&lt;/p&gt;
&lt;p&gt;How about one more improvement that will allow you to not just have your configuration on your new machine, but have your your configuration and identity with only a single command?&lt;/p&gt;
&lt;div class="divider"&gt;Final solution&lt;/div&gt;

&lt;h1&gt;Ultimate deployment&lt;/h1&gt;
&lt;p&gt;Since I have my custom domain name, I felt like there still more room for improvements. My final solution is for my machine independent setup is my &lt;strong&gt;deploy-over-url&lt;/strong&gt; dotfiles system that will:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;recognizes the current system (os x or linux)&lt;/li&gt;
&lt;li&gt;downloads my entire configuration via a specified protocol (https or ssh)&lt;/li&gt;
&lt;li&gt;creates a new ssh key if I need it&lt;/li&gt;
&lt;li&gt;uploads the created or existing ssh key to GitHub and BitBucket&lt;/li&gt;
&lt;li&gt;deploys my downloaded configuration files&lt;/li&gt;
&lt;li&gt;installs the necessary tools to ready to work&lt;/li&gt;
&lt;li&gt;and it does this through a convenient command line menu system&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All I have to do is type in the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;bash &amp;lt;(curl -fsSL tiborsimon.io/dotfiles)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I can choose what protocol do I want to use for downloading the configuration. If I choose &lt;strong&gt;https&lt;/strong&gt; the configuration will download instantly, and the ssh key generation will be skipped, since I only need my user name and password for GitHub to push back the config modification I will make later. If I choose &lt;strong&gt;ssh&lt;/strong&gt; for the download protocol, I will be prompted if to create a new ssh key, and optionally upload it ti GitHub or BitBucket. &lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this way I automated all of the critical stepts I do not want to repeate every time on a new machine.&lt;/p&gt;
&lt;p&gt;You can find detailed informations about my URL deployment and automated ssh key upload in my dedicated articles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tiborsimon.io/tools/dotfiles-with-url-deployment/"&gt;Dotfiles with URL deployment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tiborsimon.io/programming/upload-ssh-key-via-github-api/"&gt;Upload ssh key via Github API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to take a look at the system itself, you can go to my &lt;a href="https://github.com/tiborsimon/dotfiles"&gt;dotfiles GitHub repo&lt;/a&gt;.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Oh the irony.. Exactly after I typed this sentence my machine froze while traveling home on a bus.. :D Commit often, people! Espacially when you turned off swap file generation in vim :D&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="dotfiles"></category><category term="tools"></category><category term="script"></category><category term="linux"></category><category term="unix"></category></entry><entry><title>Dotfiles with URL deployment</title><link href="https://tiborsimon.io/tools/dotfiles-with-url-deployment/" rel="alternate"></link><updated>2016-03-19T00:00:00+01:00</updated><author><name>Tibor Simon</name></author><id>tag:tiborsimon.io,2016-03-19:tools/dotfiles-with-url-deployment/</id><summary type="html">&lt;p&gt;I started to improve my &lt;strong&gt;dotfiles&lt;/strong&gt; system with &lt;strong&gt;one command URL deployment&lt;/strong&gt;. In this way I can run a single command on a virgin system to deploy my configuration. This method works on OS X as well as any Linux system.&lt;/p&gt;
&lt;h2&gt;How does it work?&lt;/h2&gt;
&lt;p&gt;I use &lt;code&gt;curl&lt;/code&gt; to download the &lt;strong&gt;bootstrap&lt;/strong&gt; script which will prepare the machine to be able to clone my dotfiles repo, and then it runs the &lt;strong&gt;deploy&lt;/strong&gt; script.&lt;/p&gt;
&lt;p&gt;To download a script stored on &lt;strong&gt;GitHub&lt;/strong&gt; you can use the raw file listing. My &lt;strong&gt;bootstrap&lt;/strong&gt; script can be reached via the &lt;a href="https://raw.githubusercontent.com/tiborsimon/dotfiles/master/bootstrap" target="_blank"&gt;https://raw.githubusercontent.com/tiborsimon/dotfiles/master/bootstrap&lt;/a&gt; link. Notice, that this is not a convenient link to type..&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;curl https://raw.githubusercontent.com/tiborsimon/dotfiles/master/bootstrap
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I can take care of this problem by having a custom domain, and creating a redirect, I am using &lt;strong&gt;CloudFlare&lt;/strong&gt; as a nameserver and &lt;em&gt;ssl&lt;/em&gt; provider, so I can set up a custom &lt;strong&gt;Page Rule&lt;/strong&gt; to redirect the &lt;code&gt;tiborsimon.io/dotfiles&lt;/code&gt; to the raw script listing.&lt;/p&gt;
&lt;div class="gallery"&gt;
  &lt;img class="jslghtbx-thmb" src="/images/articles/dotfiles/custom-page-forward-rule.png" alt="CloudFlare custom Page Rule" data-jslghtbx data-jslghtbx-caption="CloudFlare custom Page Rule" data-jslghtbx-group="dotfiles-group-01" /&gt;
&lt;/div&gt;

&lt;p&gt;In this way, I can type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;curl tiborsimon.io/dotfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Downloading and executing the script&lt;/h2&gt;
&lt;p&gt;The script is available for execution. The next step is to use it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sh &amp;lt;(curl -fsSL tiborsimon.io/dotfiles)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can feed the raw sript to &lt;code&gt;sh&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt; or &lt;code&gt;zsh&lt;/code&gt;. Curl will download the script in a subshell, then it will return the downloaded script, which we will feed to the &lt;code&gt;sh&lt;/code&gt; in this example.&lt;/p&gt;
&lt;p&gt;The flags make sure, curl not corrupt the script during download:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; -f, --fail          Fail silently (no output at all) on HTTP errors (H)
 -s, --silent        Silent mode (don&amp;#39;t output anything)
 -S, --show-error    Show error. With -s, make curl show errors when they occur
 -L, --location      Follow redirects (H)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Make sure you have the latest curl on your system, because older curl versions tend to act weird with the &lt;em&gt;HTTPS&lt;/em&gt; protocol, and wont be able to connect.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[vagrant@localhost ~]$ bash &amp;lt;(curl -fsSLv https://tiborsimon.io/dotfiles)
* About to connect() to tiborsimon.io port 443 (#0)
*   Trying 104.18.43.82... connected
* Connected to tiborsimon.io (104.18.43.82) port 443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
*   CAfile: /etc/pki/tls/certs/ca-bundle.crt
  CApath: none
* NSS error -12286
* Closing connection #0
* SSL connect error
curl: (35) SSL connect error
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;We can now use our scripts via URL deployment. You can install &lt;strong&gt;Docker&lt;/strong&gt; in this way for example.&lt;/p&gt;</summary><category term="dotfiles"></category><category term="tools"></category><category term="script"></category><category term="url"></category><category term="forward"></category><category term="hack"></category></entry><entry><title>BusPirate setup for OSX</title><link href="https://tiborsimon.io/tools/buspirate-setup-for-osx/" rel="alternate"></link><updated>2015-09-13T00:00:00+02:00</updated><author><name>Tibor Simon</name></author><id>tag:tiborsimon.io,2015-09-13:tools/buspirate-setup-for-osx/</id><summary type="html">&lt;p&gt;On my windows machine I used &lt;strong&gt;Putty&lt;/strong&gt;
for this purpose. In mac there is &lt;strong&gt;Zterm&lt;/strong&gt; as an alternative, but I wanted to
use the terminal. &lt;strong&gt;Screen&lt;/strong&gt; is the perfect alternative for this job. The
workflow is the following:&lt;/p&gt;
&lt;h3&gt;1. Find out the serial number of your BusPirate&lt;/h3&gt;
&lt;p&gt;To be able to communicate your BusPirate you have to know it's serial number.
List the connected devices before you connect your Buspirate with the following
command: &lt;code&gt;$ ls /dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This command will list all the connected devices. Save them somewhere, and then
connect your BusPirate and list the devices again. Find the one that is only
present when you connect your BusPirate to your machine.&lt;/p&gt;
&lt;p&gt;There you go, mine was: &lt;code&gt;tty.usbserial-AD01W63E&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2. Connect to your device&lt;/h3&gt;
&lt;p&gt;Use &lt;strong&gt;screen&lt;/strong&gt; to connect to your BusPirate:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ screen /dev/tty.usbserial-AD01W63E 115200 8N1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The BusPirate console should appear on your terminal. To exit the session press
&lt;kbd&gt;control&lt;/kbd&gt;+&lt;kbd&gt;a&lt;/kbd&gt; then &lt;kbd&gt;k&lt;/kbd&gt; and after the prompt press
&lt;kbd&gt;y&lt;/kbd&gt; to kill the screen.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Screen&lt;/strong&gt; could be weird at first, but there are tons of shortcuts that will
help you. &lt;a href="http://ss64.com/osx/screen.html"&gt;Screen manual for osx&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;3. Make your life easier&lt;/h3&gt;
&lt;p&gt;Create an alias for the connection by writing into your &lt;em&gt;~/.bash_profile&lt;/em&gt;
file.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alias buspirate='screen /dev/tty.usbserial-AD01W63E 115200 8N1'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Source the modified file or restart the terminal, and type in &lt;code&gt;buspirate&lt;/code&gt;, and
the BusPirate terminal should open.&lt;/p&gt;</summary><category term="tools"></category><category term="embedded"></category><category term="device"></category></entry></feed>